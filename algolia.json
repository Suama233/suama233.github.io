
[
  
  
  {
    "objectID": "1745622472",
    "permalink": "/post/binary_search/",
    "title": "[琐碎简记]二分查找、离散边界确认与终止点选择",
    
    "content": "注：本篇使用语言：C++\n基本背景与类似情况\r二分查找原理本身很简单：对一顺序数组取中间值，比较其与目标大小，让中间值成为新边界，二分缩短区间。此过程迭代进行，直到找到或找不到目标，时间复杂度$O(logn)$\n典型的类似情况是快排，因为二者本质上都是在选取中间值并更新边界的过程。\n具体分析与处理\r对中间索引的微处理\r理想状态而言应该是一直选取到中间，然后更新：比如在目标值大于中间值时，更新左边界为中间本身，右边界不变。如此往复直到夹逼出一个数\n但索引本身是离散的，这导致的问题是数学算式mid=(left+right)/2可能出现索引mid是浮点数的情况，毕竟卡到两数中间时无法取值。而代码中mid的唯一写法也只能是mid=(left+right)/2（一个等效写法是(right-left)/2+left，二者完全相同，不展开），这会导致mid其实既可能是正中间，也可能是中间稍左的位置。\n如果递归函数传参时直接将mid本身传进去，就会导致在只剩两个数时无法继续更新的情况（mid会一直与左边界相等）。而递归函数一般来说做特判都是逻辑对全过程不统一然后出bug的前兆，故应该意识到理论和实际是有差距的，需要具体情况进行微调。\n解决方法是利用离散本身的特点：“mid需要成为下一次递归的边界”本身已经暗示了一个事实：其对应的数已经被判断过了。在连续情况下这代表着mid是一个开区间而非闭区间，但因为其对应的位置本身不变而有被忽视的可能，但在这里，开闭直接决定了了传入的是mid±1还是其本身。\n也就是说，原来的方法的错误原因是，每次递归都会进行一次多余的比较，而该次比较是能对是否继续递归产生影响的。也就是说，还是逻辑没有捋清楚导致的。\n对终止判断的选取\r如果能考虑到mid更新时需要手动±1，这里会好想到些，不过或许还是积累记住更为重要？\n递归函数的终止是难点。除去比较好理解的因为达到目的而结束递归，另一种对无法达成目的的判断更不好想到（比如这里可能目标根本不在数组里）\n考虑到二分缩减区间的直观解释，无法达成显然代表着即使区间缩完也没有找到。而区间缩完也就代表着左边界等于右边界。\n这是必然能达成的吗？由于mid的最小移动量（相对于左边界）是0（靠奇数除2后舍去小数），而每次mid只会取代一个边界，另一方不变，而更新边界时数量上只有1的变化，故应该是能做到相等的。\n但用相等判据需要判断 …",
    
    "date": "2025-04-26 07:07:52",
    "updated": "2025-04-26 07:12:52"
  }
  
  , 
  {
    "objectID": "1744893712",
    "permalink": "/post/smart_ptr/",
    "title": "[学习随笔] C++智能指针",
    
    "content": "\r三种智能指针\r概述：是什么，及其参与的生态位\rC++ 11后，标准库（std）中新加入了四种指针：unique_ptr,shared_ptr,weak_ptr,auto_ptr(最后一种在C++17 后被废弃因而本文不做任何涉及)。它们对应的传统位置是C++的裸指针（和前者相比，纯粹的一个T* ptr没有被封装，故得名）。它们的创建与删除操作对应了裸指针的new,delete操作。也就是说，它的核心任务是在堆上人为分配资源，但同时利用了栈与作用域的特性，实现了更安全的资源分配。\n安全在哪？\r裸指针指针每次创建都需要手动调用delete删除。这可能会有以下问题： 忘记delete 当程序逻辑很复杂时，找不对调用delete的时机 delete错东西（指针指向发生变化后原来指向的内存找不回来却也不能再被分配，或如链表等在删除时少删了几个结点） 既然程序结束时一定其创建的资源会被卸载，不能不管它吗？ 显然不能。程序存在逻辑漏洞 对于长期运行程序，没有靠这个卸载的机会 这种结束程序强行截断可能导致有些模块逻辑没闭环，留下可以被外界接入的契机 程序发生意外时，可能有些内存被强制卸载为下次启动留下bug（类似上一条）\n而相对的，智能指针能只管创建，而可以在其所属作用域结束后自动卸载。这样就不用考虑忘记或删错东西的情况。同时它还能在遭遇意外时也自动执行delete，这也就是“异常安全”保证（异常不是形容词）\n如果有些对象生存周期和程序本身一样（或中途创建，到程序结束时才被卸载），那它和等到主函数结束让系统自动删有区别吗？\n显然有的。让程序出发与结束时同状态是正常设计该有的事，而不能将这种是交由系统的强行执行（就像重写构造、析构函数） 对于这些资源，是“它们的生存周期本来就该到程序结束”，这和“忘了删”形式上一样，本质上不同 需要考虑到将来这些资源需要提前被卸载的可能。用智能指针是能让自己有掌控它被卸载的时机的（这个可能体现在运行逻辑设计上而不是非要自己明显地意识到） 该何时用智能指针？\r从目前学到的来看，应该是“尽量用”。\n也就是：在要用指针是首先考虑用unique_ptr，如果其在功能上不够或在含义上有更契合的，则考虑后两种智能指针，总之不是裸指针\n智能指针（尤其unique_ptr）的开销是很小的，故不用在这方面节省性能\n简单对比三种智能指针\r首先在OOP情境下许多模块类需 …",
    
    "date": "2025-04-17 20:41:52",
    "updated": "2025-04-18 02:26:52"
  }
  
  , 
  {
    "objectID": "1678903200",
    "permalink": "/post/hello/",
    "title": "Hello World",
    
    "content": "ここにいるよ、わたしたち。\n",
    
    "date": "2023-03-15 11:00:00",
    "updated": "2023-03-15 11:00:00"
  }
  
]