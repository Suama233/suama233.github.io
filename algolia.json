
[
  
  
  {
    "objectID": "1744893712",
    "permalink": "/post/smart_ptr/",
    "title": "[学习随笔] C++智能指针",
    
    "content": "\r三种智能指针\r概述：是什么，及其参与的生态位\rC++ 11后，标准库（std）中新加入了四种指针：unique_ptr,shared_ptr,weak_ptr,auto_ptr(最后一种在C++17 后被废弃因而本文不做任何涉及)。它们对应的传统位置是C++的裸指针（和前者相比，纯粹的一个T* ptr没有被封装，故得名）。它们的创建与删除操作对应了裸指针的new,delete操作。也就是说，它的核心任务是在堆上人为分配资源，但同时利用了栈与作用域的特性，实现了更安全的资源分配。\n安全在哪？\r裸指针指针每次创建都需要手动调用delete删除。这可能会有以下问题： 忘记delete 当程序逻辑很复杂时，找不对调用delete的时机 delete错东西（指针指向发生变化后原来指向的内存找不回来却也不能再被分配，或如链表等在删除时少删了几个结点） 既然程序结束时一定其创建的资源会被卸载，不能不管它吗？ 显然不能。程序存在逻辑漏洞 对于长期运行程序，没有靠这个卸载的机会 这种结束程序强行截断可能导致有些模块逻辑没闭环，留下可以被外界接入的契机 程序发生意外时，可能有些内存被强制卸载为下次启动留下bug（类似上一条）\n而相对的，智能指针能只管创建，而可以在其所属作用域结束后自动卸载。这样就不用考虑忘记或删错东西的情况。同时它还能在遭遇意外时也自动执行delete，这也就是“异常安全”保证（异常不是形容词）\n如果有些对象生存周期和程序本身一样（或中途创建，到程序结束时才被卸载），那它和等到主函数结束让系统自动删有区别吗？\n显然有的。让程序出发与结束时同状态是正常设计该有的事，而不能将这种是交由系统的强行执行（就像重写构造、析构函数） 对于这些资源，是“它们的生存周期本来就该到程序结束”，这和“忘了删”形式上一样，本质上不同 需要考虑到将来这些资源需要提前被卸载的可能。用智能指针是能让自己有掌控它被卸载的时机的（这个可能体现在运行逻辑设计上而不是非要自己明显地意识到） 该何时用智能指针？\r从目前学到的来看，应该是“尽量用”。\n也就是：在要用指针是首先考虑用unique_ptr，如果其在功能上不够或在含义上有更契合的，则考虑后两种智能指针，总之不是裸指针\n智能指针（尤其unique_ptr）的开销是很小的，故不用在这方面节省性能\n简单对比三种智能指针\r首先在OOP情境下许多模块类需 …",
    
    "date": "2025-04-17 20:41:52",
    "updated": "2025-04-18 02:26:52"
  }
  
  , 
  {
    "objectID": "1678903200",
    "permalink": "/post/hello/",
    "title": "Hello World",
    
    "content": "ここにいるよ、わたしたち。\n",
    
    "date": "2023-03-15 11:00:00",
    "updated": "2023-03-15 11:00:00"
  }
  
]